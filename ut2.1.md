# UT2.1 Repaso POO en Java y conceptos de desarrollo

## Introducci√≥n

El desarrollo de **interfaces gr√°ficas** permite la creaci√≥n del canal de comunicaci√≥n entre el usuario y la aplicaci√≥n, por esta raz√≥n requiere de especial atenci√≥n en su dise√±o.

En la actualidad, las herramientas de desarrollo permiten la implementaci√≥n del c√≥digo relativo a una interfaz a trav√©s de vistas dise√±o que facilitan y hacen m√°s intuitivo el proceso de creaci√≥n. La programaci√≥n orientada a objetos permite utilizar entidades o componentes que tienen su propia identidad y comportamiento.

![Free icon \&quot;Layout 3 icon&quot;](media/14683c68c38e0f4e98bb5577b7ba1cb4.png)

En este unidad se ver√°n en detalle los principales tipos de componentes de diferentes librer√≠as as√≠ como sus caracter√≠sticas m√°s importantes.

La distribuci√≥n de este tipo de elementos depende de los llamados **layout**, los cuales permiten situar los elementos en la interfaz.

Una misma aplicaci√≥n puede presentar m√°s de un tipo de ventana, principal o de di√°logo. Las ventanas de di√°logo definen los llamados di√°logos modales o no modales, elementos destacados en el desarrollo de interfaces. La combinaci√≥n de tipos de ventanas y elementos de dise√±o es infinita.

```tip
Un **componente software** est√° formado por **clases** creadas para ser reutilizadas y que puede ser manipulada por una herramienta de desarrollo de aplicaciones visual.
```

Se define por su **estado** que se almacena en un conjunto de propiedades, las cuales pueden ser modificadas para adaptar el componente al programa en el que se inserte. Tambi√©n tiene un comportamiento que se define por los **eventos** ante los que responde y los **m√©todos** que ejecuta ante dichos eventos.

Un subconjunto de los atributos y los m√©todos forman la **interfaz** del componente.

Para que pueda ser distribuida se **empaqueta** con todo lo necesario para su correcto funcionamiento, quedando independiente de otras bibliotecas o componentes.

![](media/4b1a7037165a4a4ff7e26f7a1d219f3c.png)

## Programaci√≥n Orientada a Objetos (POO)

En POO los objetos son entidades que tienen un determinado estado, comportamiento (m√©todo) e identidad:

-   El **estado** est√° compuesto de datos o informaciones, ser√° uno o varios atributos a los que se habr√°n asignado unos valores concretos (datos).
-   El **comportamiento** est√° definido por los m√©todos o mensajes a los que sabe responder dicho objeto, es decir, qu√© operaciones se pueden realizar con √©l.
-   La **identidad** es una propiedad de un objeto que lo diferencia del resto, dicho con otras palabras, es su identificador (concepto an√°logo al de identificador de una variable o una constante).

üí° La definici√≥n o instanciaci√≥n de un objeto, con sus propiedades y comportamiento se lleva a cabo a trav√©s de las **clases**.

üí° A su vez, los objetos disponen de mecanismos de interacci√≥n llamados **m√©todos**, que favorecen la comunicaci√≥n entre ellos.

## Caracter√≠sticas de la POO

### Abstracci√≥n

```note
La **abstracci√≥n** es un procedimiento que permite la elecci√≥n de una determinada entidad de la realidad, sus caracter√≠sticas y funciones que desempe√±an, la cual es representada mediante clases que contienen atributos y m√©todos de dicha clase.
```

![](media/3e7f62afba99f653778c6cbe1185ae5f.jpeg)

### Encapsulamiento

üí° En POO, se acostumbra a proteger la informaci√≥n o el estado de los atributos para que no se pueda ver o modificar la informaci√≥n del objeto sin el mecanismo adecuado.

Para ello, se utilizan m√©todos para recuperar la informaci√≥n (**getters**) y a su vez, poder asignar (**setters**) un nuevo valor y verificar que no afecte la integridad del objeto.

![](media/2d5d9981bdfafd7eb133ca3674565154.jpeg)
![](media/d2fee658277155d3761a4f5a565b6e14.jpeg)

### Herencia

```note
üí° La **herencia** es un mecanismo que permite la definici√≥n de una clase a partir de la definici√≥n de otra ya existente.
```

Conceptos importantes:

-   **Superclase**: la clase cuyas caracter√≠sticas se heredan se conoce como superclase (o una clase base o una clase principal).
-   **Subclase**: la clase que hereda la otra clase se conoce como subclase (o una clase derivada, clase extendida o clase hija). La subclase puede agregar sus propios campos y m√©todos, adem√°s de los campos y m√©todos de la superclase.
-   **Reutilizaci√≥n**: la herencia respalda el concepto de reutilizaci√≥n, es decir, cuando queremos crear una clase nueva y ya hay una clase que incluye parte del c√≥digo que queremos, podemos derivar nuestra nueva clase de la clase existente. Al hacer esto, estamos reutilizando los campos/atributos y m√©todos de la clase existente.

**![](media/b8cc5a0524d778d042c91c5a04851d25.jpeg)**

La clase Laptop sigue siendo una computadora, tiene todos sus atributos y m√©todos, pero agrega dos **atributos** y un m√©todo a la definici√≥n original, de lo que se conoce como **superclase**

## Polimorfismo

```note
El **polimorfismo** es la capacidad que tienen los objetos de una clase en ofrecer respuesta distinta e independiente en funci√≥n de los par√°metros usados durante su invocaci√≥n.
```

![](media/2e4cdc423a49fb6db4e1cfbe6fe0a0fc.png)

## Conceptos de POO

### Clases

```note
üí° Una **clase** representa un conjunto de objetos que comparten una misma estructura (atributos) y comportamiento (m√©todos).
```

A partir de una clase se podr√°n instanciar tantos objetos correspondientes a una misma clase como se quieran. Para ello se utilizan los **constructores**.

Para llevar a cabo la **instanciaci√≥n** de una clase y as√≠ crear un nuevo objeto, se utiliza el nombre de la clase seguido de par√©ntesis. Un constructor es sint√°cticamente muy semejante a un m√©todo.

El **constructor** de una clase puede recibir argumentos, de esta forma podr√° crearse m√°s de un constructor, en funci√≥n del n√∫mero de argumentos que se indiquen en su definici√≥n. Aunque el constructor no haya sido definido expl√≠citamente, en Java siempre existe un constructor por defecto que posee el nombre de la clase y no recibe ning√∫n argumento.

### Atributos

```note
Un **objeto** es una unidad dentro de un programa que tiene un estado, y un comportamiento.
```

La informaci√≥n contenida en el objeto ser√° accesible solo a trav√©s de la ejecuci√≥n de los **m√©todos** adecuados, cre√°ndose una interfaz para la comunicaci√≥n con el mundo exterior.

Los **atributos** o propiedades definen las caracter√≠sticas del objeto. Por ejemplo, si se tiene una clase c√≠rculo, sus atributos podr√≠an ser el radio y el color, estos constituyen la estructura del objeto, que posteriormente podr√° ser modelada a trav√©s de los m√©todos oportunos.

La estructura de una clase en Java quedar√≠a formada por los siguientes bloques, de manera general: **atributos, constructor y m√©todos.**

![](media/cdad20a63135bb774d20087d2a398a95.jpeg)

### M√©todos

```note
Un **m√©todo** es una subrutina cuyo c√≥digo es definido en una clase y puede pertenecer tanto a una clase, como es el caso de los m√©todos de clase o est√°ticos, como a un objeto, como es el caso de los m√©todos de instancia.
```

Los m√©todos definen el comportamiento de un objeto, es decir, toda aquella acci√≥n que se quiera realizar sobre la clase tiene que estar previamente definida en un m√©todo.

-   **getter**: permiten leer el valor de la propiedad. Tienen la estructura:

        public \<TipoPropiedad\> get\<NombrePropiedad\>( )

-   **setter**: permiten establecer el valor de la propiedad. Tiene la estructura:

        public void set\<NombrePropiedad\>(\<TipoPropiedad\> valor)

### Componente

Para que una clase sea considerada un **componente** debe cumplir ciertas normas:

-   Debe poder **modificarse** para adaptarse a la aplicaci√≥n en la que se integra.
-   Debe tener **persistencia**, es decir, debe poder guardar el estado de sus propiedades cuando han sido modificadas.
-   Debe tener **introspecci√≥n**, es decir, debe permitir a un IDE que pueda reconocer ciertos elementos de dise√±o como los nombres de las funciones miembros o m√©todos y definiciones de las clases, y devolver esa informaci√≥n.
-   Debe poder gestionar **eventos**.

    ![](media/00814fd29c42b93c70af85d7ac9ad945.png)

## Programaci√≥n de eventos

```note
üí° Los **eventos** son acciones o sucesos que se generan en aplicaciones gr√°ficas definidas en los componentes y ocasionado por los usuarios, como presionar un bot√≥n, ingresar un texto, cambiar de color, etc.
```

-   Los eventos le corresponden a las interacciones del usuario con los componentes
-   Los componentes est√°n asociados a distintos tipos de eventos
-   Un evento ser√° un objeto que representa un mensaje as√≠ncrono que tiene otro objeto como destinatario

![](media/c51573d4890a3b31dff8125bb0b96317.jpeg)

Para poder crear una conexi√≥n entre dos o m√°s ventanas, en primer lugar, es necesario crearlas. El paso de una ventana a otra se produce tras la ocurrencia de un **evento**, como por ejemplo la pulsaci√≥n sobre un bot√≥n.

![](media/8d4c6d4a34fee5292bf67b5bfcc3b28c.jpeg)

Tras la creaci√≥n de las ventanas se sit√∫an los botones de conexi√≥n y se modifican sus propiedades de apariencia. Este elemento puede situarse dentro de un *layout*.

Para crear el evento escuchador asociado a este bot√≥n basta con hacer doble *clic* sobre √©l y de forma autom√°tica se generar√° el siguiente c√≥digo en la clase de la ventana de la interfaz donde estamos implementando el bot√≥n conector.

Para que el componente pueda reconocer el **evento** y responder ante el tendr√°s que hacer lo siguiente:

-   Crear una clase para los eventos que se lancen.
-   Definir una interfaz que represente el oyente (**listener**) asociado al evento. Debe incluir una operaci√≥n para el procesamiento del evento.
-   Definir dos operaciones, para a√±adir y eliminar oyentes.

    Si queremos tener m√°s de un oyente para el evento tendremos que almacenar internamente estos oyentes en una estructura de datos como *ArrayList* o *LinkedList*.

-   Finalmente, recorrer la estructura de datos interna llamando a la operaci√≥n de procesamiento del evento de todos los oyentes registrados.

## Introspecci√≥n y reflexi√≥n

La **introspecci√≥n** es una caracter√≠stica que permite a las herramientas de programaci√≥n visual arrastrar y soltar un componente en la zona de dise√±o de una aplicaci√≥n y determinar din√°micamente qu√© m√©todos de interfaz, propiedades y eventos del componente est√°n disponibles.

Esto se puede conseguir de diferentes formas, pero en el nivel m√°s bajo se encuentra una caracter√≠stica denominada **reflexi√≥n**, que busca aquellos m√©todos definidos como p√∫blicos que empiezan por get o set, es decir, se basa en el uso de **patrones de dise√±o**, o sea, en establecer reglas en la construcci√≥n de la clase de forma que mediante el uso de una nomenclatura espec√≠fica se permita a la herramienta encontrar la interfaz de un componente.

![](media/10dc2b2006666bb3ea391e9c786b5d4c.png)

## Empaquetado de componentes

```note
El empaquetado de componentes y aplicaciones consiste en proporcionar las aplicaciones o sus componentes en forma de paquetes. Estos paquetes est√°n formados por los programas ejecutables de la aplicaci√≥n, as√≠ como por las bibliotecas de las que depende y otros tipos de ficheros (como im√°genes, traducciones, etc.), 
```

Tras realizar el empaquetado de aplicaciones es necesario que las aplicaciones puedan ser instaladas de una manera r√°pida y sencilla, para lo que se cuenta con los instaladores o paquetes autoinstalables.

Una vez creado un componente, se puede empaquetar para poder distribuirlo y reutilizarlo despu√©s. Para ello se necesitar√° el paquete **jar** que empaqueta en formato ZIP todas las clases que forman el componente:

-   El propio componente
    -   Objetos Customizer
    -   Clases de utilidad o recursos que requiera el componente, etc.

![](media/f6ff59ccf257d1379f8308cba257d9f3.png)

![](media/24d698105172077367b15e743e6399cb.png)El paquete jar debe incluir un fichero de manifiesto (con extensi√≥n .MF) que describa su contenido, por ejemplo:


### Metodolog√≠as de desarrollo √°gil

```note
La **metodolog√≠a de desarrollo √°gil** es un enfoque de desarrollo de software que se basa en principios y valores que promueven la flexibilidad, la colaboraci√≥n, la adaptabilidad y la entrega continua de software de alta calidad. 
```

![](media/234234234.png)


Se basa en varios pilares fundamentales:
- **Entrega incremental**: En lugar de esperar hasta que todo el software est√© completo, el desarrollo √°gil se basa en la entrega de incrementos de funcionalidad en intervalos cortos y regulares, conocidos como iteraciones o sprints.
- La **colaboraci√≥n con el cliente** debe estar por encima de la negociaci√≥n de contratos. El contrato fijar√° los t√©rminos del acuerdo, pero lo realmente importante es trabajar de forma cerca y flexible con el cliente.
- Se debe responder al **cambio constante**, en vez de seguir un plan est√°tico. El cambio continuo es inevitable y se debe responder de forma cercana y flexible.
- El software de trabajo y los equipos est√°n por encima de la documentaci√≥n exaustiva. Documentar es importante, pero el objetivo es desarrollar software y cuidar el talento.
- Ritmo constante y **mejora continua**: Los equipos √°giles trabajan en ciclos regulares, como sprints de dos a cuatro semanas. Despu√©s de cada iteraci√≥n, se realiza una retrospectiva para evaluar lo que funcion√≥ bien y lo que no.

![](media/435345345642.png)

#### Scrum

Scrum es un proceso en el que se aplican de manera regular un conjunto de buenas pr√°cticas para trabajar colaborativamente, en equipo, y obtener el mejor resultado posible de un proyecto. La metodolog√≠a scrum consiste en abordar cualquier proyecto dividi√©ndolo en sprints o partes m√°s peque√±as y abordarlo mediante unos **roles** espec√≠ficos y sistema de asignaci√≥n de tareas.

![](media/243456456456sdf.png)

Existen varias implementaciones de sistemas para gestionar el proceso de Scrum, que van desde notas amarillas "post-it" y pizarras hasta paquetes de software. Si se utiliza una pizarra con notas cualquier miembro del equipo podr√° ver tres columnas: trabajo pendiente ("To Do"), tareas en curso ("in progress") y hecho ("Done"). De un solo vistazo, una persona puede ver en qu√© est√°n trabajando los dem√°s en un momento determinado.

##### Roles principales

- Propietario del producto: Perfil del cliente ligado al proyecto, que act√∫a como su altavoz. Encargado de garantizar que el proyecto sigue los objetivos marcados en todo momento.
- Scrum Master (facilitador) Es el responsable del cumplimiento de las reglas del marco scrum. Se asegura que estas son entendidas por la organizaci√≥n y de que se realiza el trabajo conforme a ellas. Elimina los obst√°culos que impiden que se desarrolle el objetivo del sprint.  
- Equipo de Desarrolladores: Cada uno de los profesionales que realizan la entrega del incremento de producto. Es recomendable un equipo de 3 a 9 personas.  

###### Eventos

- Sprint: per√≠odo de tiempo, generalmente de 2 a 4 semanas, durante el cual el equipo trabaja en la implementaci√≥n de los elementos de trabajo del backlog.
- Reuni√≥n de Planificaci√≥n del Sprint: Al comienzo del sprint, el equipo se re√∫ne con el Product Owner para seleccionar los elementos de trabajo del backlog que se abordar√°n durante el Sprint y crear un plan para completarlos.
- Reuniones Diarias (Scrum Diario): El equipo se re√∫ne diariamente durante el Sprint para compartir el progreso e identificar obst√°culos.
- Revisi√≥n del Sprint: Al final de cada Sprint, el equipo demuestra el trabajo completado al Product Owner y otras partes interesadas para obtener retroalimentaci√≥n.
- Restrospectiva: analizar futuras mejoras.

![](media/86786dfg45345345s.png)


### Metodolog√≠a Clean code

La metodolog√≠a Clean Code es una filosof√≠a que refiere a un conjunto de principios y pr√°cticas de programaci√≥n que tienen como objetivo producir un c√≥digo fuente claro, legible, estructurado y de f√°cil mantenimiento. 
Clean Code se enfoca en mejorar la calidad del c√≥digo y hacerlo m√°s comprensible para los desarrolladores y otros miembros del equipo.
Sus principios generales son los siguientes:
- La secuencia de ejecuci√≥n del programa tiene una l√≥gica y una estructura lo m√°s sencilla posible
- La relaci√≥n entre las diferentes partes del c√≥digo es claramente visible.
- La tarea o funci√≥n de cada clase, funci√≥n, m√©todo y variable es comprensible a primera vista.
    - Las clases y m√©todos son reducidos: tienen una √∫nica y clara tarea.
    - Los nombres de las clases y m√©todos son auto-identificativos de su funci√≥n.

#### Evitar repeticiones (DRY) 

De acuerdo con el principio *DRY (Don‚Äôt Repeat Yourself)*, cada funci√≥n debe tener una representaci√≥n √∫nica y, por lo tanto, inequ√≠voca dentro del sistema general .
Ejemplo c√≥digo redundante y repetido:

```java
//Variante A
let username = getUserName();
let password= getPassword();
let user = { username, password};
client.post(user).then(/*Variante A*/);

//Variante B
let username = getUserName();
let password= getPassword();
let user = { username, password};
client.get(user).then(/*Variante B*/);
```

Usando el principio DRY quedar√≠a de la siguiente forma:

```java
function getUser(){
  return {
    user:getUserName();
    password:getPassword();
  }
}

//Variante A
client.post(getUser()).then(/*Variante A*/ );

//Variante B
client.get(getUser()).then(/*Variante B*/);
```

#### C√≥digo legible

El c√≥digo no solo debe funcionar y ser interpretado por la m√°quina que lo ejecuta, sino que¬†tambi√©n debe ser comprensible para otros desarrolladores, especialmente si se trabaja en proyectos colaborativos. Por lo tanto, en el √°mbito del desarrollo de software, la legibilidad del c√≥digo siempre es m√°s importante que su concisi√≥n. 
Un buen ejemplo de creaci√≥n de c√≥digo legible ser√≠a nombrar las variables.

Por ejemplo, en lugar de usar la siguiente declaraci√≥n:
```java
int d;
```
Usar una en la que se identifique el uso de la variable:
```java
int dias_fecha;
```

## Patrones de dise√±o

Los **patrones de dise√±o de software**, tambi√©n llamados **arquitectura de software** son la gu√≠a o patr√≥n que vamos a utilizar en el desarrollo de nuestro programa.

Los patrones de dise√±o son soluciones habituales a problemas que ocurren con frecuencia en el dise√±o de software. Son como planos prefabricados que se pueden personalizar para resolver un problema de dise√±o recurrente en el c√≥digo.

A menudo los patrones se confunden con **algoritmos** porque ambos conceptos describen soluciones t√≠picas a problemas conocidos. Mientras que un algoritmo siempre define un grupo claro de acciones para lograr un objetivo, un patr√≥n es una descripci√≥n de m√°s alto nivel de una soluci√≥n. El c√≥digo del mismo patr√≥n aplicado a dos programas distintos puede ser diferente.

![](media/5dafb86f9788e80ddcd0821334d98ae8.png)


### MVC

```note
El Modelo Vista Controlador (MVC) es un patr√≥n de dise√±o te√≥rico que separa los **datos** de la aplicaci√≥n (modelo), la **interfaz** (vista), y la **l√≥gica** de funcionamiento (controlador).
```

-   **Modelo**: Contiene la informaci√≥n de los datos. Es una representaci√≥n.
-   **Vista**: Es la interfaz de usuario, es decir, con lo que interact√∫a el usuario.
-   **Controlador**: es la conexi√≥n entre el modelo y la vista.

![](media/mvc.png)

### MVVM

El Modelo Vista Vista-Modelo (MVVM) es parecido al MVC pero en este caso se sustituye al **controlador** por **Vista-Modelo** o Modelo de Vista (*ViewModel*).

A diferencia del MVC, la **vista** tiene una referencia al modelo de vista, pero el **vista- modelo** no sabe nada de la vista. La vista tampoco recibe informaci√≥n del modelo, ya que el vista-modelo hace la funci√≥n de proveedor de datos.

![](media/mvvm.png)

## Herramientas de construcci√≥n de proyectos

**Ant**, **Maven**, y **Gradle** son herramientas de automatizaci√≥n en la construcci√≥n de proyectos y b√°sicamente se emplean para compilar proyectos. No son compatibles entre s√≠ y de su elecci√≥n depende el desarrollo inicial de nuestro proyecto.

![](media/herramientas.png)

```note
Una **dependencia** es una aplicaci√≥n o una biblioteca requerida por otro programa para poder funcionar correctamente.
```

Las dependencias en Java se pueden gestionar de la siguiente forma:

-   Descargar el archivo jar de la biblioteca requerida manualmente desde Internet y a√±adirlo a nuestro proyecto.
-   Escribir un script que descargar√° autom√°ticamente la biblioteca de una fuente externa a trav√©s de la red.

Al ser una tarea pesada, pronto aparecieron **herramienta de gesti√≥n de dependencias,** las cuales resuelven y gestionan las dependencias que requiera nuestra aplicaci√≥n.

Las **herramientas de construcci√≥n** automatizan la creaci√≥n de aplicaciones ejecutables a partir del c√≥digo fuente. La construcci√≥n incorpora la compilaci√≥n, el enlace y el empaquetado del c√≥digo en una forma utilizable o ejecutable.

### Ant

Apache Ant es una herramienta de l√≠nea de comandos basada en Java que utiliza archivos XML para definir scripts de compilaci√≥n. Se usa principalmente para compilaciones de Java, pero tambi√©n se puede usar para el desarrollo de C / C ++. 

Ejemplo del fichero *build.xml* para la clase principal de holamundo:

        <project>
        <target name="clean">
            <deletedir="classes" />
        </target>
        <target name="compile" depends="clean">
            <mkdirdir="classes" />
            <javacsrcdir="src" destdir="classes" />
        </target>
        <target name="jar" depends="compile">
        <mkdirdir="jar" />
        <jardestfile="jar/HelloWorld.jar" basedir="classes">
            <manifest>
                <attributename="Main-Class"
                value="antExample.HelloWorld" />
            </manifest>
        </jar>
        </target>
        <target name="run" depends="jar">
            <java jar="jar/HelloWorld.jar" fork="true" />
        </target>
        </project>


### Maven

Maven fue desarrollado para resolver los problemas que enfrentan los scripts basados ‚Äã‚Äãen Ant e introdujo la **gesti√≥n autom√°tica de dependencias**, facilitando en gran manera el desarrollo. Adem√°s, la estructura de proyectos est√° estandarizada.

Ejemplo del fichero *pom.xml* de la clase principal de holamundo del ejemplo anterior:

        <projectxmlns="http://maven.apache.org/POM/4.0.0"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
        http://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>
        <groupId>baeldung</groupId>
        <artifactId>mavenExample</artifactId>
        <version>0.0.1-SNAPSHOT</version>
        <description>Mavenexample</description>

        <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>
        </dependencies>
        </project>

### Gradle

Gradle combina el poder de Ant y Maven. La primera versi√≥n de Gradle se lanz√≥ en 2012. Se est√° adoptando r√°pidamente. Google lo est√° usando actualmente para el sistema operativo Android.

En lugar de XML, Gradle usa el lenguaje Groovy. Como resultado, las secuencias de comandos de compilaci√≥n en Gradle son m√°s f√°ciles de escribir y leer.

Ejemplo del fichero *build.gradle* de la clase principal de holamundo del ejemplo:

        applyplugin: 'java'
        repositories{
            mavenCentral()
        }
        jar{
            baseName= 'gradleExample'
            version= '0.0.1-SNAPSHOT'
        }
        dependencies{
        testImpl    ementation'junit:junit:4.12'
        }

## Repositorios Github

```note
Un repositorio contiene todos los archivos de un proyecto y el historial de revisiones de cada uno de ellos.
```

Github es un portal creado para alojar el c√≥digo de las aplicaciones de cualquier desarrollador, y que fue comprada por Microsoft en junio del 2018. La plataforma est√° creada para que los desarrolladores suban el c√≥digo de sus aplicaciones y herramientas, y que como usuario no s√≥lo puedas descargarte la aplicaci√≥n, sino tambi√©n entrar a su perfil para leer sobre ella o colaborar con su desarrollo.

![](media/githublogo.png)

Utiliza el sistema de control de versiones Git dise√±ado por Linus Torvalds. Con dicho sistema de gesti√≥n de versiones los desarrolladores pueden administrar su proyecto, trabajando colaborativamente y gestionar las distintas versiones para evitar confusiones.

### Github classroom

Github classroom es una herramienta espec√≠fica para el trabajo con estudiantes.

Acceder a Github Clasroom y desde ah√≠ a la tarea que se especifique con las instrucciones de desarrollo requeridas:

![](media/a9676197c22b9ccd12bfd3807227a6d3.jpeg)


### Comandos git

![](media/a368506762f9f3e596e4409f14b23482.png)![](media/981334452a05339b78e1b26cd3e6b0b9.jpeg)


### Integraci√≥n con Netbeans

Una vez abierto el proyecto en Netbeans habr√° que inicializarlo haciendo clic en

\*Versioning\>\***Initialize Git Repository** y dejar la ruta donde est√° alojado el proyecto.

![](media/16639bd1b425f4039f2d381897a83be2.jpeg)

A continuaci√≥n se har√° un **Commit** del proyecto actual en *git\>Commit* y se le dar√° una descripci√≥n. El *Commit* guardar√° los datos en el repositorio local antes de actualizarse.

![](media/e89aa3acd626dde6f464766f150374f2.jpeg)


Para guardar los cambios en el repositorio remoto de Github habr√° que hacer un **push**. Para ello ir a *Git\>Remote\>push* e introducir nuestras credenciales de Github en *Specify Git Repository Location*.

![](media/4e666ecd5d55119376cfd015ea632ca1.jpeg)

![](media/f5e9b94250acb8a758bc9c91404bde70.png)

Desde el a√±o pasado es necesario generar un **token de acceso personal** en lugar de contrase√±a. Para ello habr√° que acceder a *Github.com\>settings\>Developer Settings* y en *Personal access tokens*

## Netbeans

üí° Los **debugger** son herramientas imprescindibles en la programaci√≥n, sin las cuales ser√≠a muy complicado detectar cualquier problema, desde un m√≠nimo error de s√≠ntesis perdido en cientos de rutinas hasta escribir por equivocaci√≥n un c√≥digo que genere un bucle infinito para ciertas casu√≠sticas.

En los desarrollos actuales m√°s del 70% del tiempo se dedica al diese√±o del modelo y debugeo continuo, con apenas un 25% del tiempo dedicado al desarrollo de c√≥digo.

![](media/12f45487965423232f.png)

### Debugger

![](media/b917128d263061d75f14af22d74cf555.jpeg)



| **Step Over (F8)**              | Ejecuta una l√≠nea de c√≥digo. Si la instrucci√≥n es una llamada a un m√©todo, ejecuta el m√©todo sin entrar dentro del c√≥digo del m√©todo.                                                                                          |
|---------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Step Over Expression (Mayus+F8) | Ejecuta una llamada de m√©todo en una expresi√≥n. Si una expresi√≥n tiene varias llamadas a m√©todos, se puede usar para recorrer la expresi√≥n y ver el valor de cada llamada a m√©todo en la expresi√≥n en la ventana de variables. |
| **Step Into (F7)**              | Ejecuta una l√≠nea de c√≥digo. Si la instrucci√≥n es una llamada a un m√©todo, salta al m√©todo y contin√∫a la ejecuci√≥n por la primera l√≠nea del m√©todo.                                                                            |
| Step Out (Ctrl + F7)            | Si la l√≠nea de c√≥digo actual se encuentra dentro de un m√©todo, se ejecutar√°n todas las instrucciones que queden del m√©todo y se volver√° a la instrucci√≥n desde la que se llam√≥ al m√©todo.                                      |
| Run to Cursor (F4)              | Se ejecuta el programa hasta la instrucci√≥n donde se encuentre el cursor.                                                                                                                                                      |
| Continue (F5)                   | La ejecuci√≥n del programa contin√∫a hasta el siguiente breakpoint. Si no existe un breakpoint se ejecuta hasta el final.                                                                                                        |
| Finish Debugger                 | Terminar la depuraci√≥n del programa.                                                                                                                                                                                           |

### Proyectos

Principales carpetas de un proyecto Java creado en Netbeans:
- Carpeta **src** contiene los archivos fuente codificados para este trabajo en lenguaje Java (extensi√≥n .java). Dichos archivos se encuentran distribuidos en carpetas, o paquetes en notaci√≥n de Java. Adem√°s de los archivos fuente, se incluyen im√°genes (archivos con extensi√≥n .gif) y otros ficheros de texto utilizados.
- Carpeta **build** es utilizada por NetBeans para almacenar los archivos objeto resultado de la compilaci√≥n. Estos archivos tienen extensi√≥n .class y contienen la traducci√≥n de Java a bytecode o lenguaje que entiende la M√°quina Virtual de Java.
-Carpeta **dist** es utilizada por NetBeans para almacenar el archivo con extensi√≥n .jar, que no es m√°s que un archivo comprimido en formato ZIP que contiene toda la estructura de archivos de la carpeta build. Este archivo es el que se utiliza para su distribuci√≥n por Internet.
- Carpeta **dist\javadoc** es utilizada por NetBeans para presentar la documentaci√≥n de las clases generada como archivos .html a partir de los comentarios incluidos en los .java.
- Carpeta **nbproject** es interna a NetBeans e incluye opciones de compilaci√≥n y generaci√≥n de la documentaci√≥n del proyecto.
- Carpeta **test** se corresponde con la generaci√≥n de JUnit de Java para pruebas de clases.
