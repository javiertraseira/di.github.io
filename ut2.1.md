# UT2.1 Repaso POO en Java y conceptos de desarrollo

El desarrollo de **interfaces gr√°ficas** permite la creaci√≥n del canal de comunicaci√≥n entre el usuario y la aplicaci√≥n, por esta raz√≥n requiere de especial atenci√≥n en su dise√±o.

En la actualidad, las herramientas de desarrollo permiten la implementaci√≥n del c√≥digo relativo a una interfaz a trav√©s de vistas dise√±o que facilitan y hacen m√°s intuitivo el proceso de creaci√≥n. La programaci√≥n orientada a objetos permite utilizar entidades o componentes que tienen su propia identidad y comportamiento.

![Free icon \&quot;Layout 3 icon&quot;](media/14683c68c38e0f4e98bb5577b7ba1cb4.png)

En este unidad se ver√°n en detalle los principales tipos de componentes de diferentes librer√≠as as√≠ como sus caracter√≠sticas m√°s importantes.

La distribuci√≥n de este tipo de elementos depende de los llamados **layout**, los cuales permiten situar los elementos en la interfaz.

Una misma aplicaci√≥n puede presentar m√°s de un tipo de ventana, principal o de di√°logo. Las ventanas de di√°logo definen los llamados di√°logos modales o no modales, elementos destacados en el desarrollo de interfaces. La combinaci√≥n de tipos de ventanas y elementos de dise√±o es infinita.

## Introducci√≥n

```tip
Un **componente software** est√° formado por **clases** creadas para ser reutilizadas y que puede ser manipulada por una herramienta de desarrollo de aplicaciones visual.
```

Se define por su **estado** que se almacena en un conjunto de propiedades, las cuales pueden ser modificadas para adaptar el componente al programa en el que se inserte. Tambi√©n tiene un comportamiento que se define por los **eventos** ante los que responde y los **m√©todos** que ejecuta ante dichos eventos.

Un subconjunto de los atributos y los m√©todos forman la **interfaz** del componente.

Para que pueda ser distribuida se **empaqueta** con todo lo necesario para su correcto funcionamiento, quedando independiente de otras bibliotecas o componentes.

![](media/4b1a7037165a4a4ff7e26f7a1d219f3c.png)

## Programaci√≥n Orientada a Objetos (POO)

En POO los objetos son entidades que tienen un determinado estado, comportamiento (m√©todo) e identidad:

-   El **estado** est√° compuesto de datos o informaciones, ser√° uno o varios atributos a los que se habr√°n asignado unos valores concretos (datos).
-   El **comportamiento** est√° definido por los m√©todos o mensajes a los que sabe responder dicho objeto, es decir, qu√© operaciones se pueden realizar con √©l.
-   La **identidad** es una propiedad de un objeto que lo diferencia del resto, dicho con otras palabras, es su identificador (concepto an√°logo al de identificador de una variable o una constante).

üí° La definici√≥n o instanciaci√≥n de un objeto, con sus propiedades y comportamiento se lleva a cabo a trav√©s de las **clases**.

üí° A su vez, los objetos disponen de mecanismos de interacci√≥n llamados **m√©todos**, que favorecen la comunicaci√≥n entre ellos.

## Caracter√≠sticas de la POO

### Abstracci√≥n

```note
La **abstracci√≥n** es un procedimiento que permite la elecci√≥n de una determinada entidad de la realidad, sus caracter√≠sticas y funciones que desempe√±an, la cual es representada mediante clases que contienen atributos y m√©todos de dicha clase.
```

![](media/3e7f62afba99f653778c6cbe1185ae5f.jpeg)

### Encapsulamiento

üí° En POO, se acostumbra a proteger la informaci√≥n o el estado de los atributos para que no se pueda ver o modificar la informaci√≥n del objeto sin el mecanismo adecuado.

Para ello, se utilizan m√©todos para recuperar la informaci√≥n (**getters**) y a su vez, poder asignar (**setters**) un nuevo valor y verificar que no afecte la integridad del objeto.

![](media/2d5d9981bdfafd7eb133ca3674565154.jpeg)
![](media/d2fee658277155d3761a4f5a565b6e14.jpeg)

### Herencia

```note
üí° La **herencia** es un mecanismo que permite la definici√≥n de una clase a partir de la definici√≥n de otra ya existente.
```

Conceptos importantes:

-   **Superclase**: la clase cuyas caracter√≠sticas se heredan se conoce como superclase (o una clase base o una clase principal).
-   **Subclase**: la clase que hereda la otra clase se conoce como subclase (o una clase derivada, clase extendida o clase hija). La subclase puede agregar sus propios campos y m√©todos, adem√°s de los campos y m√©todos de la superclase.
-   **Reutilizaci√≥n**: la herencia respalda el concepto de reutilizaci√≥n, es decir, cuando queremos crear una clase nueva y ya hay una clase que incluye parte del c√≥digo que queremos, podemos derivar nuestra nueva clase de la clase existente. Al hacer esto, estamos reutilizando los campos/atributos y m√©todos de la clase existente.

**![](media/b8cc5a0524d778d042c91c5a04851d25.jpeg)**

La clase Laptop sigue siendo una computadora, tiene todos sus atributos y m√©todos, pero agrega dos **atributos** y un m√©todo a la definici√≥n original, de lo que se conoce como **superclase**

## Polimorfismo

```note
El **polimorfismo** es la capacidad que tienen los objetos de una clase en ofrecer respuesta distinta e independiente en funci√≥n de los par√°metros usados durante su invocaci√≥n.
```

![](media/2e4cdc423a49fb6db4e1cfbe6fe0a0fc.png)

## Conceptos de POO

### Clases

```note
üí° Una **clase** representa un conjunto de objetos que comparten una misma estructura (atributos) y comportamiento (m√©todos).
```

A partir de una clase se podr√°n instanciar tantos objetos correspondientes a una misma clase como se quieran. Para ello se utilizan los **constructores**.

Para llevar a cabo la **instanciaci√≥n** de una clase y as√≠ crear un nuevo objeto, se utiliza el nombre de la clase seguido de par√©ntesis. Un constructor es sint√°cticamente muy semejante a un m√©todo.

El **constructor** de una clase puede recibir argumentos, de esta forma podr√° crearse m√°s de un constructor, en funci√≥n del n√∫mero de argumentos que se indiquen en su definici√≥n. Aunque el constructor no haya sido definido expl√≠citamente, en Java siempre existe un constructor por defecto que posee el nombre de la clase y no recibe ning√∫n argumento.

### Atributos

```note
Un **objeto** es una unidad dentro de un programa que tiene un estado, y un comportamiento.
```

La informaci√≥n contenida en el objeto ser√° accesible solo a trav√©s de la ejecuci√≥n de los **m√©todos** adecuados, cre√°ndose una interfaz para la comunicaci√≥n con el mundo exterior.

Los **atributos** o propiedades definen las caracter√≠sticas del objeto. Por ejemplo, si se tiene una clase c√≠rculo, sus atributos podr√≠an ser el radio y el color, estos constituyen la estructura del objeto, que posteriormente podr√° ser modelada a trav√©s de los m√©todos oportunos.

La estructura de una clase en Java quedar√≠a formada por los siguientes bloques, de manera general: **atributos, constructor y m√©todos.**

![](media/cdad20a63135bb774d20087d2a398a95.jpeg)

### M√©todos

```note
Un **m√©todo** es una subrutina cuyo c√≥digo es definido en una clase y puede pertenecer tanto a una clase, como es el caso de los m√©todos de clase o est√°ticos, como a un objeto, como es el caso de los m√©todos de instancia.
```

Los m√©todos definen el comportamiento de un objeto, es decir, toda aquella acci√≥n que se quiera realizar sobre la clase tiene que estar previamente definida en un m√©todo.

-   **getter**: permiten leer el valor de la propiedad. Tienen la estructura:

        public \<TipoPropiedad\> get\<NombrePropiedad\>( )

-   **setter**: permiten establecer el valor de la propiedad. Tiene la estructura:

        public void set\<NombrePropiedad\>(\<TipoPropiedad\> valor)

### Componente

Para que una clase sea considerada un **componente** debe cumplir ciertas normas:

-   Debe poder **modificarse** para adaptarse a la aplicaci√≥n en la que se integra.
-   Debe tener **persistencia**, es decir, debe poder guardar el estado de sus propiedades cuando han sido modificadas.
-   Debe tener **introspecci√≥n**, es decir, debe permitir a un IDE que pueda reconocer ciertos elementos de dise√±o como los nombres de las funciones miembros o m√©todos y definiciones de las clases, y devolver esa informaci√≥n.
-   Debe poder gestionar **eventos**.

    ![](media/00814fd29c42b93c70af85d7ac9ad945.png)

## Programaci√≥n de eventos

```note
üí° Los **eventos** son acciones o sucesos que se generan en aplicaciones gr√°ficas definidas en los componentes y ocasionado por los usuarios, como presionar un bot√≥n, ingresar un texto, cambiar de color, etc.
```

-   Los eventos le corresponden a las interacciones del usuario con los componentes
-   Los componentes est√°n asociados a distintos tipos de eventos
-   Un evento ser√° un objeto que representa un mensaje as√≠ncrono que tiene otro objeto como destinatario

![](media/c51573d4890a3b31dff8125bb0b96317.jpeg)

Para poder crear una conexi√≥n entre dos o m√°s ventanas, en primer lugar, es necesario crearlas. El paso de una ventana a otra se produce tras la ocurrencia de un **evento**, como por ejemplo la pulsaci√≥n sobre un bot√≥n.

![](media/8d4c6d4a34fee5292bf67b5bfcc3b28c.jpeg)

Tras la creaci√≥n de las ventanas se sit√∫an los botones de conexi√≥n y se modifican sus propiedades de apariencia. Este elemento puede situarse dentro de un *layout*.

Para crear el evento escuchador asociado a este bot√≥n basta con hacer doble *clic* sobre √©l y de forma autom√°tica se generar√° el siguiente c√≥digo en la clase de la ventana de la interfaz donde estamos implementando el bot√≥n conector.

Para que el componente pueda reconocer el **evento** y responder ante el tendr√°s que hacer lo siguiente:

-   Crear una clase para los eventos que se lancen.
-   Definir una interfaz que represente el oyente (**listener**) asociado al evento. Debe incluir una operaci√≥n para el procesamiento del evento.
-   Definir dos operaciones, para a√±adir y eliminar oyentes.

    Si queremos tener m√°s de un oyente para el evento tendremos que almacenar internamente estos oyentes en una estructura de datos como *ArrayList* o *LinkedList*.

-   Finalmente, recorrer la estructura de datos interna llamando a la operaci√≥n de procesamiento del evento de todos los oyentes registrados.

## Introspecci√≥n y reflexi√≥n

La **introspecci√≥n** es una caracter√≠stica que permite a las herramientas de programaci√≥n visual arrastrar y soltar un componente en la zona de dise√±o de una aplicaci√≥n y determinar din√°micamente qu√© m√©todos de interfaz, propiedades y eventos del componente est√°n disponibles.

Esto se puede conseguir de diferentes formas, pero en el nivel m√°s bajo se encuentra una caracter√≠stica denominada **reflexi√≥n**, que busca aquellos m√©todos definidos como p√∫blicos que empiezan por get o set, es decir, se basa en el uso de **patrones de dise√±o**, o sea, en establecer reglas en la construcci√≥n de la clase de forma que mediante el uso de una nomenclatura espec√≠fica se permita a la herramienta encontrar la interfaz de un componente.

![](media/10dc2b2006666bb3ea391e9c786b5d4c.png)

## Empaquetado de componentes

Una vez creado un componente, se puede empaquetar para poder distribuirlo y reutilizarlo despu√©s. Para ello se necesitar√° el paquete **jar** que empaqueta en formato ZIP todas las clases que forman el componente:

-   El propio componente
    -   Objetos Customizer
    -   Clases de utilidad o recursos que requiera el componente, etc.

![](media/f6ff59ccf257d1379f8308cba257d9f3.png)

![](media/24d698105172077367b15e743e6399cb.png)El paquete jar debe incluir un fichero de manifiesto (con extensi√≥n .MF) que describa su contenido, por ejemplo:

## Patrones de dise√±o

Los **patrones de dise√±o de software**, tambi√©n llamados **arquitectura de software** son la gu√≠a o patr√≥n que vamos a utilizar en el desarrollo de nuestro programa.

Los patrones de dise√±o son soluciones habituales a problemas que ocurren con frecuencia en el dise√±o de software. Son como planos prefabricados que se pueden personalizar para resolver un problema de dise√±o recurrente en el c√≥digo.

A menudo los patrones se confunden con **algoritmos** porque ambos conceptos describen soluciones t√≠picas a problemas conocidos. Mientras que un algoritmo siempre define un grupo claro de acciones para lograr un objetivo, un patr√≥n es una descripci√≥n de m√°s alto nivel de una soluci√≥n. El c√≥digo del mismo patr√≥n aplicado a dos programas distintos puede ser diferente.

![](media/5dafb86f9788e80ddcd0821334d98ae8.png)

### MVC

```note
El Modelo Vista Controlador (MVC) es un patr√≥n de dise√±o te√≥rico que separa los **datos** de la aplicaci√≥n (modelo), la **interfaz** (vista), y la **l√≥gica** de funcionamiento (controlador).
```

-   **Modelo**: Contiene la informaci√≥n de los datos. Es una representaci√≥n.
-   **Vista**: Es la interfaz de usuario, es decir, con lo que interact√∫a el usuario.
-   **Controlador**: es la conexi√≥n entre el modelo y la vista.

![](media/mvc.png)

### MVVM

El Modelo Vista Vista-Modelo (MVVM) es parecido al MVC pero en este caso se sustituye al **controlador** por **Vista-Modelo** o Modelo de Vista (*ViewModel*).

A diferencia del MVC, la **vista** tiene una referencia al modelo de vista, pero el **vista- modelo** no sabe nada de la vista. La vista tampoco recibe informaci√≥n del modelo, ya que el vista-modelo hace la funci√≥n de proveedor de datos.

![](media/mvvm.png)

## Herramientas de construcci√≥n de proyectos

**Ant**, **Maven**, y **Gradle** son herramientas de automatizaci√≥n en la construcci√≥n de proyectos y b√°sicamente se emplean para compilar proyectos. No son compatibles entre s√≠ y de su elecci√≥n depende el desarrollo inicial de nuestro proyecto.

![](media/herramientas.png)

Una **dependencia** es una aplicaci√≥n o una biblioteca requerida por otro programa para poder funcionar correctamente.

Las dependencias en Java se pueden gestionar de la siguiente forma:

-   Descargar el archivo jar de la biblioteca requerida manualmente desde Internet y a√±adirlo a nuestro proyecto.
    -   Escribir un script que descargar√° autom√°ticamente la biblioteca de una fuente externa a trav√©s de la red.

Al ser una tarea pesada, pronto aparecieron **herramienta de gesti√≥n de dependencias,** las cuales resuelven y gestionan las dependencias que requiera nuestra aplicaci√≥n.

Las **herramientas de construcci√≥n** automatizan la creaci√≥n de aplicaciones ejecutables a partir del c√≥digo fuente. La construcci√≥n incorpora la compilaci√≥n, el enlace y el empaquetado del c√≥digo en una forma utilizable o ejecutable.

### Ant

Apache Ant es una herramienta de l√≠nea de comandos basada en Java que utiliza archivos XML para definir scripts de compilaci√≥n. Se usa principalmente para compilaciones de Java, pero tambi√©n se puede usar para el desarrollo de C / C ++. 

Ejemplo del fichero build.xml para la clase principal de holamundo:

        <project>
        <target name="clean">
            <deletedir="classes" />
        </target>
        <target name="compile" depends="clean">
            <mkdirdir="classes" />
            <javacsrcdir="src" destdir="classes" />
        </target>
        <target name="jar" depends="compile">
        <mkdirdir="jar" />
        <jardestfile="jar/HelloWorld.jar" basedir="classes">
            <manifest>
                <attributename="Main-Class"
                value="antExample.HelloWorld" />
            </manifest>
        </jar>
        </target>
        <target name="run" depends="jar">
            <java jar="jar/HelloWorld.jar" fork="true" />
        </target>
        </project>


### Maven

Maven fue desarrollado para resolver los problemas que enfrentan los scripts basados ‚Äã‚Äãen Ant e introdujo la **gesti√≥n autom√°tica de dependencias**, facilitando en gran manera el desarrollo. Adem√°s, la estructura de proyectos est√° estandarizada.

Ejemplo del fichero pom.xml de la clase principal de holamundo del ejemplo anterior:

        <projectxmlns="http://maven.apache.org/POM/4.0.0"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
        http://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>
        <groupId>baeldung</groupId>
        <artifactId>mavenExample</artifactId>
        <version>0.0.1-SNAPSHOT</version>
        <description>Mavenexample</description>

        <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>
        </dependencies>
        </project>

### Gradle

Gradle combina el poder de Ant y Maven. La primera versi√≥n de Gradle se lanz√≥ en 2012. Se est√° adoptando r√°pidamente. Google lo est√° usando actualmente para el sistema operativo Android.

En lugar de XML, Gradle usa el lenguaje Groovy. Como resultado, las secuencias de comandos de compilaci√≥n en Gradle son m√°s f√°ciles de escribir y leer.

Ejemplo del fichero build.gradle de la clase principal de holamundo del ejemplo:

        applyplugin: 'java'
        repositories{
            mavenCentral()
        }
        jar{
            baseName= 'gradleExample'
            version= '0.0.1-SNAPSHOT'
        }
        dependencies{
        testImpl    ementation'junit:junit:4.12'
        }

## Github Classroom

Acceder con la direcci√≥n especificada por el profesor y desde ah√≠ a la tarea que se especifique con las instrucciones de desarrollo requeridas:
![](media/a9676197c22b9ccd12bfd3807227a6d3.jpeg)


**Comandos git**

![](media/a368506762f9f3e596e4409f14b23482.png)![](media/981334452a05339b78e1b26cd3e6b0b9.jpeg)


### Integraci√≥n con Netbeans

Una vez abierto el proyecto en Netbeans habr√° que inicializarlo haciendo clic en

\*Versioning\>\***Initialize Git Repository** y dejar la ruta donde est√° alojado el proyecto.

![](media/16639bd1b425f4039f2d381897a83be2.jpeg)

A continuaci√≥n se har√° un **Commit** del proyecto actual en *git\>Commit* y se le dar√° una descripci√≥n. El *Commit* guardar√° los datos en el repositorio local antes de actualizarse.

![](media/e89aa3acd626dde6f464766f150374f2.jpeg)


Para guardar los cambios en el repositorio remoto de Github habr√° que hacer un **push**. Para ello ir a *Git\>Remote\>push* e introducir nuestras credenciales de Github en *Specify Git Repository Location*.

![](media/4e666ecd5d55119376cfd015ea632ca1.jpeg)

![](media/f5e9b94250acb8a758bc9c91404bde70.png)

Desde el a√±o pasado es necesario generar un **token de acceso personal** en lugar de contrase√±a. Para ello habr√° que acceder a *Github.com\>settings\>Developer Settings* y en *Personal access tokens*

## Netbeans

üí° Los **debugger** son herramientas imprescindibles en la programaci√≥n, sin las cuales ser√≠a muy complicado detectar cualquier problema, desde un m√≠nimo error de s√≠ntesis perdido en cientos de rutinas hasta escribir por equivocaci√≥n un c√≥digo que genere un bucle infinito para ciertas casu√≠sticas.

![](media/b917128d263061d75f14af22d74cf555.jpeg)



| **Step Over (F8)**              | Ejecuta una l√≠nea de c√≥digo. Si la instrucci√≥n es una llamada a un m√©todo, ejecuta el m√©todo sin entrar dentro del c√≥digo del m√©todo.                                                                                          |
|---------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Step Over Expression (Mayus+F8) | Ejecuta una llamada de m√©todo en una expresi√≥n. Si una expresi√≥n tiene varias llamadas a m√©todos, se puede usar para recorrer la expresi√≥n y ver el valor de cada llamada a m√©todo en la expresi√≥n en la ventana de variables. |
| **Step Into (F7)**              | Ejecuta una l√≠nea de c√≥digo. Si la instrucci√≥n es una llamada a un m√©todo, salta al m√©todo y contin√∫a la ejecuci√≥n por la primera l√≠nea del m√©todo.                                                                            |
| Step Out (Ctrl + F7)            | Si la l√≠nea de c√≥digo actual se encuentra dentro de un m√©todo, se ejecutar√°n todas las instrucciones que queden del m√©todo y se volver√° a la instrucci√≥n desde la que se llam√≥ al m√©todo.                                      |
| Run to Cursor (F4)              | Se ejecuta el programa hasta la instrucci√≥n donde se encuentre el cursor.                                                                                                                                                      |
| Continue (F5)                   | La ejecuci√≥n del programa contin√∫a hasta el siguiente breakpoint. Si no existe un breakpoint se ejecuta hasta el final.                                                                                                        |
| Finish Debugger                 | Terminar la depuraci√≥n del programa.                                                                                                                                                                                           |
